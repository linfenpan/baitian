<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>TLS (SSL) Node.js v0.10.18 文档 中文版</title>
  <link rel="stylesheet" href="/public/api_assets/style.css">
  <link rel="stylesheet" href="/public/api_assets/sh.css">
  <link rel="canonical" href="http://nodejs.org/api/tls.html">
</head>
<body class="alt apidoc" id="api-section-tls">

    <div id="intro" class="interior">
        <a href="/api/" title="返回首页">
            <img id="logo" src="http://nodejs.org/images/logo-light.png" alt="node.js">
        </a>
    </div>
    <div id="content" class="clearfix">
        <div id="column2" class="interior">
            <ul>
                <li><a href="/api/" class="docs current">文档首页</a></li>
                <li><a href="http://nodejs.org/api/">英文版文档</a></li>
            </ul>
            <div style="margin-top:44px; font-size:12px;">
              <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh"><img alt="知识共享许可协议" style="border-width:0" src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh">知识共享署名-非商业性使用 3.0 未本地化版本许可协议</a>进行许可。
            </div>
        </div>

        <div id="column1" class="interior">
          <header>
            <h1>Node.js v0.10.18 手册 &amp; 文档</h1>
            <div id="gtoc">
              <p>
                <a href="index.html" name="toc">索引</a> |
                <a href="all.html">在单一页面中浏览</a> |
                <a href="tls.json">JSON格式</a>
              </p>
            </div>
            <hr>
          </header>

          <div id="toc">
            <h2>目录</h2>
            <ul>
<li><a href="#tls_tls_ssl_304">TLS (SSL)</a><ul>
<li><a href="#tls_104">客户端初始化的对缓解攻击的重新协商</a></li>
<li><a href="#tls_npn_sni_304">NPN 和 SNI</a></li>
<li><a href="#tls_tls_getciphers_304">tls.getCiphers()</a></li>
<li><a href="#tls_tls_createserver_options_secureconnectionlistener_304">tls.createServer(options, [secureConnectionListener])</a></li>
<li><a href="#tls_tls_connect_options_callback_304">tls.connect(options, [callback])</a></li>
<li><a href="#tls_tls_connect_port_host_options_callback_304">tls.connect(port, [host], [options], [callback])</a></li>
<li><a href="#tls_class_tls_tlssocket_208">Class: tls.TLSSocket</a></li>
<li><a href="#tls_new_tls_tlssocket_socket_options_304">new tls.TLSSocket(socket, options)</a></li>
<li><a href="#tls_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized_304">tls.createSecurePair([credentials], [isServer], [requestCert], [rejectUnauthorized])</a></li>
<li><a href="#tls_securepair_304">类: SecurePair</a><ul>
<li><a href="#tls_secure_304">事件: &apos;secure&apos;</a></li>
</ul>
</li>
<li><a href="#tls_tls_server_304">类: tls.Server</a><ul>
<li><a href="#tls_secureconnection_304">事件: &apos;secureConnection&apos;</a></li>
<li><a href="#tls_event_clienterror_304">Event: &apos;clientError&apos;</a></li>
<li><a href="#tls_newsession_304">事件: &apos;newSession&apos;</a></li>
<li><a href="#tls_resumesession_304">事件: &apos;resumeSession&apos;</a></li>
<li><a href="#tls_server_listen_port_host_callback_304">server.listen(port, [host], [callback])</a></li>
<li><a href="#tls_server_close_304">server.close()</a></li>
<li><a href="#tls_server_address_304">server.address()</a></li>
<li><a href="#tls_server_addcontext_hostname_credentials_304">server.addContext(hostname, credentials)</a></li>
<li><a href="#tls_server_maxconnections_304">server.maxConnections</a></li>
<li><a href="#tls_server_connections_304">server.connections</a></li>
</ul>
</li>
<li><a href="#tls_cryptostream_304">类: CryptoStream</a><ul>
<li><a href="#tls_cryptostream_byteswritten_304">cryptoStream.bytesWritten</a></li>
</ul>
</li>
<li><a href="#tls_class_tls_tlssocket_209">Class: tls.TLSSocket</a><ul>
<li><a href="#tls_secureconnect_304">事件: &apos;secureConnect&apos;</a></li>
<li><a href="#tls_tlssocket_authorized_304">tlsSocket.authorized</a></li>
<li><a href="#tls_tlssocket_authorizationerror_304">tlsSocket.authorizationError</a></li>
<li><a href="#tls_tlssocket_getpeercertificate_304">tlsSocket.getPeerCertificate()</a></li>
<li><a href="#tls_tlssocket_getcipher_304">tlsSocket.getCipher()</a></li>
<li><a href="#tls_tlssocket_renegotiate_options_callback_304">tlsSocket.renegotiate(options, callback)</a></li>
<li><a href="#tls_tlssocket_address_304">tlsSocket.address()</a></li>
<li><a href="#tls_tlssocket_remoteaddress_304">tlsSocket.remoteAddress</a></li>
<li><a href="#tls_tlssocket_remoteport_304">tlsSocket.remotePort</a></li>
<li><a href="#tls_tlssocket_localaddress_304">tlsSocket.localAddress</a></li>
<li><a href="#tls_tlssocket_localport_304">tlsSocket.localPort</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>

          <div id="apicontent">
            <div class="translate-section" data-hash="145c39a9e9cdc960d42e3ac0b5f4fda0">

<h1>TLS (SSL)<span><a href="#tls_tls_ssl_304" id="tls_tls_ssl_304">#</a></span></h1>
</div>

<div class="translate-section" data-hash="399d2125371b1bed03f110e3be489c63">

<pre><code>稳定度: 3 - 稳定</code></pre>
</div>

<div class="translate-section" data-hash="340ccb0b121dba15010d9d89b162e623">

<p>使用 <code>require(&apos;tls&apos;)</code> 来访问此模块。

</p>
</div>

<div class="translate-section" data-hash="423b5200a968afc362ac16aa3478401f">

<p><code>tls</code> 模块使用 OpenSSL 来提供传输层安全协议（Transport Layer Security）和/或安全套接层（Secure Socket Layer）：加密过的流通讯。

</p>
</div>

<div class="translate-section" data-hash="9c805f24fea54cc0b38f81efa98ee44c">

<p>TLS/SSL 是一种公钥/私钥架构。每个客户端和服务器都必有一个私钥。一个私钥使用类似的方式创建：

</p>
</div>

<div class="translate-section" data-hash="4d5920ff6f58e691523d5f99ab5368f6">

<pre><code>openssl genrsa -out ryans-key.pem 1024</code></pre>
</div>

<div class="translate-section" data-hash="b874100bf595b22707137a749b56624c">

<p>所有服务器和某些客户端需要具备证书。证书是证书办法机构签发或自签发的公钥。获取证书的第一步是创建一个“证书签发申请”（CSR）文件。使用这条命令完成：

</p>
</div>

<div class="translate-section" data-hash="c06f7c7ca1a360ecddba5e64b3339b07">

<pre><code>openssl req -new -key ryans-key.pem -out ryans-csr.pem</code></pre>
</div>

<div class="translate-section" data-hash="25e7613185453b30d5f65edcdc3abfa0">

<p>像这样使用 CSR 创建一个自签名证书：

</p>
</div>

<div class="translate-section" data-hash="a088da845b7d4e314e0652e362ce4e9f">

<pre><code>openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem</code></pre>
</div>

<div class="translate-section" data-hash="ea7f8c63b0e03e1a7f511fde3c26f151">

<p>又或者你可以将 CSR 发送给一个数字证书认证机构请求签名。

</p>
</div>

<div class="translate-section" data-hash="44853bd349363585ac5c52e7482b5528">

<p>(TODO: 对于创建一个CA文档, 感兴趣的用户暂时只能看Node的源代码<code>test/fixtures/keys/Makefile</code>

</p>
</div>

<div class="translate-section" data-hash="7a524d3fc507c7bb6cf9edaa2900012e">

<p>像这样创建 .pfx 或 .p12：

</p>
</div>

<div class="translate-section" data-hash="1c7248778da43fed0e23ea39a5fad33b">

<pre><code>openssl pkcs12 -export -in agent5-cert.pem -inkey agent5-key.pem \
    -certfile ca-cert.pem -out agent5.pfx</code></pre>
</div>

<div class="translate-section" data-hash="e33e840756a4a8db465d1075f59bb231">

<ul>
<li><code>in</code>:  certificate</li>
<li><code>inkey</code>: private key</li>
<li><code>certfile</code>: all CA certs concatenated in one file like
<code>cat ca1-cert.pem ca2-cert.pem &gt; ca-cert.pem</code></li>
</ul>
</div>

<div class="translate-section" data-hash="ad90c4bebd7ed4843ed7545cd4e2eee5">

<h2>客户端初始化的对缓解攻击的重新协商<span><a href="#tls_104" id="tls_104">#</a></span></h2>
</div>

<!-- type=misc -->

<div class="translate-section" data-hash="c86ce11a9cac72c10f68c0d7de7cef4e">

<p>TLS协议会令客户端可以重新协商TLS会话的某些方面。但是，会话的重新协商是需要相应量的服务器端资源的，所以导致其变成一个阻断服务攻击（denial-of-service）的潜在媒介。

</p>
</div>

<div class="translate-section" data-hash="35042d6cb36695696c9dfba4206ab2b4">

<p>为了减低这种情况的发生，重新协商被限制在每10分钟三次。如果超过这个数目，那么在<a href="#tls_class_tls_tlssocket">tls.TLSSocket</a>实例上就会分发一个错误。这个限制是可设置的：

</p>
</div>

<div class="translate-section" data-hash="a84dbdef94cc0a04e1ff41b8c164684f">

<ul>
<li><code>tls.CLIENT_RENEG_LIMIT</code>: 重新协商的次数限制，默认为3。</li>
</ul>
</div>

<div class="translate-section" data-hash="92c41f60e695f457431d1cb27f05551c">

<ul>
<li><code>tls.CLIENT_RENEG_WINDOW</code>: 重新协商窗口的秒数，默认为600（10分钟）。</li>
</ul>
</div>

<div class="translate-section" data-hash="e67d2640b986cb5702a5415006427ed5">

<p>除非你完全理解整个机制和清楚自己要干什么，否则不要改变这个默认值。

</p>
</div>

<div class="translate-section" data-hash="d8b5e2dd0728a4d38bed43a16b5e3c97">

<p>要测试你的服务器的话，用命令 <code>openssl s_client -connect 地址:端口</code>连接上服务器，然后敲击<code>R&lt;CR&gt;</code>（字母键<code>R</code>加回车键）几次。

</p>
</div>

<div class="translate-section" data-hash="f25c6922f280507a9710341ef0d71309">

<h2>NPN 和 SNI<span><a href="#tls_npn_sni_304" id="tls_npn_sni_304">#</a></span></h2>
</div>

<!-- type=misc -->

<div class="translate-section" data-hash="fd776edd1aa58460587833735f9c60fa">

<p>NPN (Next Protocol Negotiation，下一个协议的协商)和SNI (Server Name Indication，服务器名称指示)是TLS握手扩展，它们允许你：

</p>
</div>

<div class="translate-section" data-hash="5733b3456318fbf7eb007d5a378044c2">

<ul>
<li>NPN - 同一个TLS服务器使用多种协议 (HTTP, SPDY)</li>
<li>SNI - 同一个TLS服务器使用多个主机名，与其相应的SSL证书。</li>
</ul>
</div>

<div class="translate-section" data-hash="25b47968d53b0519b1cbb40139954b27">

<h2>tls.getCiphers()<span><a href="#tls_tls_getciphers_304" id="tls_tls_getciphers_304">#</a></span></h2>
</div>

<div class="translate-section" data-hash="4abb84cb50fb1f208e41dbcff6d91da8">

<p>返回一个数组，其中包含了所支持的SSL加密器的名字。

</p>
</div>

<div class="translate-section" data-hash="81eeab9506186e2dca8faefa78d54067">

<p>实例：

</p>
</div>

<div class="translate-section" data-hash="44b42775ca7fc21960509673ea3bd961">

<pre><code>var ciphers = tls.getCiphers();
console.log(ciphers); // [&apos;AES128-SHA&apos;, &apos;AES256-SHA&apos;, ...]</code></pre>
</div>

<div class="translate-section" data-hash="2f516e2dfbe2da0ff7ec64156418d70f">

<h2>tls.createServer(options, [secureConnectionListener])<span><a href="#tls_tls_createserver_options_secureconnectionlistener_304" id="tls_tls_createserver_options_secureconnectionlistener_304">#</a></span></h2>
</div>

<div class="translate-section" data-hash="f4db6ea2c98b40852ebd879b5a82b3a0">

<p>新建一个新的 <a href="#tls_class_tls_server">tls.Server</a>.  The <code>connectionListener</code> 参数会自动设置为 <a href="#tls_event_secureconnection">secureConnection</a> 事件的监听器. 这个 <code>options</code> 对象有这些可能性:

</p>
</div>

<div class="translate-section" data-hash="716861e7800777b43efd61369becf2e9">

<ul>
<li><code>pfx</code>: 一个String 或<code>Buffer</code>包含了私钥, 证书和CA certs, 一般是 PFX 或者 PKCS12 格式. (Mutually exclusive with
the <code>key</code>, <code>cert</code> and <code>ca</code> options.)</li>
</ul>
</div>

<div class="translate-section" data-hash="a00a4b0d9da3e5f878f00d84b74f6465">

<ul>
<li><code>key</code>: 一个字符串或 <code>Buffer</code>对象，其中包含了PEF格式的服务器的私钥。 (必需)</li>
</ul>
</div>

<div class="translate-section" data-hash="221243ca1a04baba286e9e9414b68d53">

<ul>
<li><code>passphrase</code>: 私钥或pfx密码的字符串。</li>
</ul>
</div>

<div class="translate-section" data-hash="6ff4177c6e56ff50ed51584be4fc2064">

<ul>
<li><code>cert</code>: 字符串或者 <code>Buffer</code>，包含PEM格式的服务器证书密码。（必选）</li>
</ul>
</div>

<div class="translate-section" data-hash="756b9899f731d900f0daa5f78a956bc2">

<ul>
<li><code>ca</code>: An array of strings or <code>Buffer</code>s of trusted certificates. If this is
omitted several well known &quot;root&quot; CAs will be used, like VeriSign.
These are used to authorize connections.</li>
</ul>
</div>

<div class="translate-section" data-hash="a1cf27a951ad56e6da360a924a696612">

<ul>
<li><code>crl</code> : Either a string or list of strings of PEM encoded CRLs (Certificate
Revocation List)</li>
</ul>
</div>

<div class="translate-section" data-hash="3c7ad9da26d8acd55b65211f0fa336c3">

<ul>
<li><code>ciphers</code>: 一个字符串，描述了使用或排除的cipher。</li>
</ul>
</div>

<div class="translate-section" data-hash="8689ec4270155cf3c4886955506171ab">

<pre><code>**NOTE**: Previous revisions of this section suggested `AES256-SHA` as an
acceptable cipher. Unfortunately, `AES256-SHA` is a CBC cipher and therefore
susceptible to BEAST attacks. Do *not* use it.</code></pre>
</div>

<div class="translate-section" data-hash="99a461dd4ee65a293aeff0cfdb88a13f">

<ul>
<li><code>handshakeTimeout</code>: Abort the connection if the SSL/TLS handshake does not
finish in this many milliseconds. The default is 120 seconds.</li>
</ul>
</div>

<div class="translate-section" data-hash="c22eb7dba237bddbcf8f3f114fa4217b">

<pre><code>`tls.Server`对象在握手超时时，总会触发`&apos;clientError&apos;`事件。</code></pre>
</div>

<div class="translate-section" data-hash="94e2eb3f4fa9540a706798446aa424b0">

<ul>
<li><code>honorCipherOrder</code> : 当选择cipher时，使用服务器设置，而不是客户端设置。</li>
</ul>
</div>

<div class="translate-section" data-hash="2944f0bc1bd10498a7fbbb4bdd882ff6">

<pre><code>Although, this option is disabled by default, it is *recommended* that you
use this option in conjunction with the `ciphers` option to mitigate
BEAST attacks.</code></pre>
</div>

<div class="translate-section" data-hash="248d168bdcf99bf77a7cb6a73d4e7b01">

<ul>
<li><code>requestCert</code>: If <code>true</code> the server will request a certificate from
clients that connect and attempt to verify that certificate. Default:
<code>false</code>.</li>
</ul>
</div>

<div class="translate-section" data-hash="e745f1f97c57bc04958abd8031d66223">

<ul>
<li><code>rejectUnauthorized</code>: If <code>true</code> the server will reject any connection
which is not authorized with the list of supplied CAs. This option only
has an effect if <code>requestCert</code> is <code>true</code>. Default: <code>false</code>.</li>
</ul>
</div>

<div class="translate-section" data-hash="ca52ef10e60e8f00842e31ddf1551134">

<ul>
<li><code>NPNProtocols</code>: 一个数组或 <code>Buffer</code>，包含了可能的 NPN 协议。(协议应根据优先级排序）</li>
</ul>
</div>

<div class="translate-section" data-hash="d0959372181d900810d301a24c12084e">

<ul>
<li><code>SNICallback(servername, cb)</code>: A function that will be called if client
supports SNI TLS extension. Two argument will be passed to it: <code>servername</code>,
and <code>cb</code>. <code>SNICallback</code> should invoke <code>cb(null, ctx)</code>, where <code>ctx</code> is a
SecureContext instance.
(You can use <code>crypto.createCredentials(...).context</code> to get proper
SecureContext). If <code>SNICallback</code> wasn&apos;t provided - default callback with
high-level API will be used (see below).</li>
</ul>
</div>

<div class="translate-section" data-hash="41af95080be068cdf39729f35659bd5b">

<ul>
<li><code>sessionTimeout</code>: An integer specifying the seconds after which TLS
session identifiers and TLS session tickets created by the server are
timed out. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_timeout.html">SSL_CTX_set_timeout</a> for more details.</li>
</ul>
</div>

<div class="translate-section" data-hash="6939c4944d01f15ac688d730e1105171">

<ul>
<li><code>sessionIdContext</code>: A string containing a opaque identifier for session
resumption. If <code>requestCert</code> is <code>true</code>, the default is MD5 hash value
generated from command-line. Otherwise, the default is not provided.</li>
</ul>
</div>

<div class="translate-section" data-hash="d9ade6c30aaadd09106f968f95cdf192">

<ul>
<li><code>secureProtocol</code>: The SSL method to use, e.g. <code>SSLv3_method</code> to force
SSL version 3. The possible values depend on your installation of
OpenSSL and are defined in the constant <a href="http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_PROTOCOL_METHODS">SSL_METHODS</a>.</li>
</ul>
</div>

<div class="translate-section" data-hash="e8d35e7802c8678cf2161d0403114d69">

<p>这是一个简单的应答服务器例子：

</p>
</div>

<div class="translate-section" data-hash="c6e2097183d4b43e8183298f88a5c3ff">

<pre><code>var server = tls.createServer(options, function(socket) {
  console.log(&apos;服务器已连接&apos;,
              socket.authorized ? &apos;已授权&apos; : &apos;未授权&apos;);
  socket.write(&quot;欢迎！\n&quot;);
  socket.setEncoding(&apos;utf8&apos;);
  socket.pipe(socket);
});
server.listen(8000, function() {
  console.log(&apos;server bound&apos;);
});</code></pre>
</div>

<div class="translate-section" data-hash="3a2d5fe857d8f9541136a124c2edec6c">

<p>或者

</p>
</div>

<div class="translate-section" data-hash="a635f48c8a1543ade7ef09415c826999">

<pre><code>};</code></pre>
</div>

<div class="translate-section" data-hash="114486c9b56801223fc5c1f518bd0d91">

<pre><code>var server = tls.createServer(options, function(socket) {
  console.log(&apos;服务器已连接&apos;,
              socket.authorized ? &apos;已授权&apos; : &apos;未授权&apos;);
  socket.write(&quot;欢迎！\n&quot;);
  socket.setEncoding(&apos;utf8&apos;);
  socket.pipe(socket);
});
server.listen(8000, function() {
  console.log(&apos;服务器已绑定&apos;);
});</code></pre>
<p>您可以使用 <code>openssl s_client</code> 连接这个服务器来测试：

</p>
</div>

<div class="translate-section" data-hash="c44e1b653cefb2d12a2d49a9f9017ccb">

<pre><code>openssl s_client -connect 127.0.0.1:8000</code></pre>
</div>

<div class="translate-section" data-hash="79fa2c2a155ad1b356f30265e71a7f13">

<h2>tls.connect(options, [callback])<span><a href="#tls_tls_connect_options_callback_304" id="tls_tls_connect_options_callback_304">#</a></span></h2>
<h2>tls.connect(port, [host], [options], [callback])<span><a href="#tls_tls_connect_port_host_options_callback_304" id="tls_tls_connect_port_host_options_callback_304">#</a></span></h2>
</div>

<div class="translate-section" data-hash="9875d5314b7d9452f8f3977dad05805b">

<p>Creates a new client connection to the given <code>port</code> and <code>host</code> (old API) or
<code>options.port</code> and <code>options.host</code>. (If <code>host</code> is omitted, it defaults to
<code>localhost</code>.) <code>options</code> should be an object which specifies:

</p>
</div>

<div class="translate-section" data-hash="85bbce9d04348d58f45485156e65dbd3">

<ul>
<li><code>host</code>: 客户端应连接到的主机</li>
</ul>
</div>

<div class="translate-section" data-hash="5a385903e7c60a803de7c51aa209b4f6">

<ul>
<li><code>port</code>: 客户端应连接到的端口</li>
</ul>
</div>

<div class="translate-section" data-hash="b8414c346a6cb587ee8c0bc2de99b8a3">

<ul>
<li><code>socket</code>: Establish secure connection on a given socket rather than
creating a new socket. If this option is specified, <code>host</code> and <code>port</code>
are ignored.</li>
</ul>
</div>

<div class="translate-section" data-hash="b4148da9770f061195012beda9aaaadd">

<ul>
<li><code>pfx</code>: 字符串或者 <code>Buffer</code>，包含 PFX 或 PKCS12 格式的服务器私钥、证书和CA证书。</li>
</ul>
</div>

<div class="translate-section" data-hash="e638aa8c4a456a75da959ae99b47ebde">

<ul>
<li><code>key</code>: 字符串或 <code>Buffer</code>，包含 PEM 格式的客户端私钥。</li>
</ul>
</div>

<div class="translate-section" data-hash="221243ca1a04baba286e9e9414b68d53">

<ul>
<li><code>passphrase</code>: 私钥或pfx密码的字符串。</li>
</ul>
</div>

<div class="translate-section" data-hash="2c134781b6aea1bd7900f63fd08a8bf0">

<ul>
<li><code>cert</code>: 字符串或 <code>Buffer</code>，包含PEM格式的客户端证书密码。</li>
</ul>
</div>

<div class="translate-section" data-hash="756b9899f731d900f0daa5f78a956bc2">

<ul>
<li><code>ca</code>: An array of strings or <code>Buffer</code>s of trusted certificates. If this is
omitted several well known &quot;root&quot; CAs will be used, like VeriSign.
These are used to authorize connections.</li>
</ul>
</div>

<div class="translate-section" data-hash="5fd648c58d03e83e379409a7ff2175dc">

<ul>
<li><code>rejectUnauthorized</code>: If <code>true</code>, the server certificate is verified against
the list of supplied CAs. An <code>&apos;error&apos;</code> event is emitted if verification
fails. Default: <code>true</code>.</li>
</ul>
</div>

<div class="translate-section" data-hash="b0d69cda11e2ae646635c397c661a9af">

<ul>
<li><code>NPNProtocols</code>: An array of string or <code>Buffer</code> containing supported NPN
protocols. <code>Buffer</code> should have following format: <code>0x05hello0x05world</code>,
where first byte is next protocol name&apos;s length. (Passing array should
usually be much simpler: <code>[&apos;hello&apos;, &apos;world&apos;]</code>.)</li>
</ul>
</div>

<div class="translate-section" data-hash="8d326ddb99846504c20c310aa0d1dcd9">

<ul>
<li><code>servername</code>: SNI (Server Name Indication) TLS 扩展的服务器名。</li>
</ul>
</div>

<div class="translate-section" data-hash="d9ade6c30aaadd09106f968f95cdf192">

<ul>
<li><code>secureProtocol</code>: The SSL method to use, e.g. <code>SSLv3_method</code> to force
SSL version 3. The possible values depend on your installation of
OpenSSL and are defined in the constant <a href="http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_PROTOCOL_METHODS">SSL_METHODS</a>.</li>
</ul>
</div>

<div class="translate-section" data-hash="d1afea7a90224ea7f24a025a2d8ca809">

<p><code>callback</code>参数会被作为监听器添加到<a href="#tls_event_secureconnect">&apos;secureConnect&apos;</a>事件。

</p>
</div>

<div class="translate-section" data-hash="b232cc92a696225fb387136d12e90edc">

<p><code>tls.connect()</code>返回一个<a href="#tls_class_tls_tlssocket">tls.TLSSocket</a>对象。

</p>
</div>

<div class="translate-section" data-hash="75d03e8caa718d3ba0ed7357f93fb3d3">

<p>下面是一个上述应答服务器的客户端的例子：

</p>
</div>

<div class="translate-section" data-hash="b6d22a532088be9249a25a72b55b2f75">

<pre><code>var socket = tls.connect(8000, options, function() {
  console.log(&apos;client connected&apos;,
              socket.authorized ? &apos;authorized&apos; : &apos;unauthorized&apos;);
  process.stdin.pipe(socket);
  process.stdin.resume();
});
socket.setEncoding(&apos;utf8&apos;);
socket.on(&apos;data&apos;, function(data) {
  console.log(data);
});
socket.on(&apos;end&apos;, function() {
  server.close();
});</code></pre>
</div>

<div class="translate-section" data-hash="3a2d5fe857d8f9541136a124c2edec6c">

<p>或者

</p>
</div>

<div class="translate-section" data-hash="b6d22a532088be9249a25a72b55b2f75">

<pre><code>var socket = tls.connect(8000, options, function() {
  console.log(&apos;client connected&apos;,
              socket.authorized ? &apos;authorized&apos; : &apos;unauthorized&apos;);
  process.stdin.pipe(socket);
  process.stdin.resume();
});
socket.setEncoding(&apos;utf8&apos;);
socket.on(&apos;data&apos;, function(data) {
  console.log(data);
});
socket.on(&apos;end&apos;, function() {
  server.close();
});</code></pre>
</div>

<div class="translate-section" data-hash="f49cedfdf1a25b85e777bf14b1381865">

<h2>Class: tls.TLSSocket<span><a href="#tls_class_tls_tlssocket_208" id="tls_class_tls_tlssocket_208">#</a></span></h2>
</div>

<div class="translate-section" data-hash="96873ad19a9ab0b932acdb1aed297bb7">

<p>Wrapper for instance of <a href="net.html#net_class_net_socket">net.Socket</a>, replaces internal socket read/write
routines to perform transparent encryption/decryption of incoming/outgoing data.

</p>
</div>

<div class="translate-section" data-hash="a64a876171a92ae51a3d8827a84bae48">

<h2>new tls.TLSSocket(socket, options)<span><a href="#tls_new_tls_tlssocket_socket_options_304" id="tls_new_tls_tlssocket_socket_options_304">#</a></span></h2>
</div>

<div class="translate-section" data-hash="53a8eae7473fd49a1388ebcf3880bdf1">

<p>Construct a new TLSSocket object from existing TCP socket.

</p>
</div>

<div class="translate-section" data-hash="96fb24a975ac6f33c1aff137518e48d5">

<p><code>socket</code>是一个<a href="net.html#net_class_net_socket">net.Socket</a>示例。

</p>
</div>

<div class="translate-section" data-hash="ebf7bcac8c2399a8d8ecb41029aef219">

<p><code>options</code>是一个可能包含以下属性的对象：

</p>
</div>

<div class="translate-section" data-hash="28a78a393e77bdb07b9a7104d848c435">

<ul>
<li><code>credentials</code>: 可选的，通过<code>crypto.createCredentials( ... )</code>得到的资格对象。</li>
</ul>
</div>

<div class="translate-section" data-hash="ed9af971b80a7243218803084f8d9fe2">

<ul>
<li><code>isServer</code>: 如果为真——TLS套接字将在服务器模式下实例化。</li>
</ul>
</div>

<div class="translate-section" data-hash="8a373ae4921b42b59ecf15860dc4292e">

<ul>
<li><code>server</code>: 一个可选的<a href="net.html#net_class_net_server">net.Server</a>实例</li>
</ul>
</div>

<div class="translate-section" data-hash="45a1f1a872b51cb61b7b922948bb13f1">

<ul>
<li><code>requestCert</code>: 可选的，见<a href="#tls_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized">tls.createSecurePair</a></li>
</ul>
</div>

<div class="translate-section" data-hash="c5551e3bef724a9467e7600d5b5bcf28">

<ul>
<li><code>rejectUnauthorized</code>: 可选的，见<a href="#tls_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized">tls.createSecurePair</a></li>
</ul>
</div>

<div class="translate-section" data-hash="228b65150582116b5f91ca6e459faf01">

<ul>
<li><code>NPNProtocols</code>: 可选的，见<a href="#tls_tls_createserver_options_secureconnectionlistener">tls.createServer</a></li>
</ul>
</div>

<div class="translate-section" data-hash="8608d1c626e844d0ef6c7da726bc952b">

<ul>
<li><code>SNICallback</code>: 可选的，见<a href="#tls_tls_createserver_options_secureconnectionlistener">tls.createServer</a></li>
</ul>
</div>

<div class="translate-section" data-hash="9499701e53610bbb8834cd9a8b7d6fd4">

<h2>tls.createSecurePair([credentials], [isServer], [requestCert], [rejectUnauthorized])<span><a href="#tls_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized_304" id="tls_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized_304">#</a></span></h2>
</div>

<div class="translate-section" data-hash="6b542b021eec46d9d0c2e9c51eb4275f">

<pre><code>稳定性: 0 - 已废弃。使用 tls.TLSSocket 替代。</code></pre>
</div>

<div class="translate-section" data-hash="f3be51a07824e5a39b2712b99ff000f3">

<p>Creates a new secure pair object with two streams, one of which reads/writes
encrypted data, and one reads/writes cleartext data.
Generally the encrypted one is piped to/from an incoming encrypted data stream,
and the cleartext one is used as a replacement for the initial encrypted stream.

</p>
</div>

<div class="translate-section" data-hash="5d0ad606ced87dd09850c67e2ae6aa04">

<ul>
<li><code>credentials</code>: 通过<code>crypto.createCredentials( ... )</code>得到的资格对象</li>
</ul>
</div>

<div class="translate-section" data-hash="3f03d0de187b3e91133d6f25f30d782e">

<ul>
<li><code>isServer</code>: A boolean indicating whether this tls connection should be
opened as a server or a client.</li>
</ul>
</div>

<div class="translate-section" data-hash="cf5eed3ed39e05608b5111a81c2f13a0">

<ul>
<li><code>requestCert</code>: A boolean indicating whether a server should request a
certificate from a connecting client. Only applies to server connections.</li>
</ul>
</div>

<div class="translate-section" data-hash="0de5cbebffb20da93b199dc92dd3e402">

<ul>
<li><code>rejectUnauthorized</code>: A boolean indicating whether a server should
automatically reject clients with invalid certificates. Only applies to
servers with <code>requestCert</code> enabled.</li>
</ul>
</div>

<div class="translate-section" data-hash="53732014276ca47df2eac2aa9a7ec89b">

<p><code>tls.createSecurePair()</code> returns a SecurePair object with <code>cleartext</code> and
<code>encrypted</code> stream properties.

</p>
</div>

<div class="translate-section" data-hash="470873050dd4852a71bd82cdf3c0cb34">

<p>NOTE: <code>cleartext</code> has the same APIs as <a href="#tls_class_tls_tlssocket">tls.TLSSocket</a>

</p>
</div>

<div class="translate-section" data-hash="9ef78a31e8114bed9bd037cc4b0d6fb0">

<h2>类: SecurePair<span><a href="#tls_securepair_304" id="tls_securepair_304">#</a></span></h2>
</div>

<div class="translate-section" data-hash="8633e8f3559ae15e61b9944c4a2c3112">

<p>由tls.createSecurePair返回。

</p>
</div>

<div class="translate-section" data-hash="3d671130e19309c71e55139089c8d1fb">

<h3>事件: &apos;secure&apos;<span><a href="#tls_secure_304" id="tls_secure_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="ed3f4944f5db39c57647994e6e6ceaef">

<p>The event is emitted from the SecurePair once the pair has successfully
established a secure connection.

</p>
</div>

<div class="translate-section" data-hash="299ad055b3c32dce1c366e9634d3a301">

<p>Similarly to the checking for the server &apos;secureConnection&apos; event,
pair.cleartext.authorized should be checked to confirm whether the certificate
used properly authorized.

</p>
</div>

<div class="translate-section" data-hash="345954ec35abc5ff98e86855d06bea1c">

<h2>类: tls.Server<span><a href="#tls_tls_server_304" id="tls_tls_server_304">#</a></span></h2>
</div>

<div class="translate-section" data-hash="789889d3e9cfad64fbcacb271cdc8181">

<p>This class is a subclass of <code>net.Server</code> and has the same methods on it.
Instead of accepting just raw TCP connections, this accepts encrypted
connections using TLS or SSL.

</p>
</div>

<div class="translate-section" data-hash="3ff92e96df8f3836e0cf04044ae7e574">

<h3>事件: &apos;secureConnection&apos;<span><a href="#tls_secureconnection_304" id="tls_secureconnection_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="69c2224748b9e206240c0e9b3773313c">

<p><code>function (tlsSocket) {}</code>

</p>
</div>

<div class="translate-section" data-hash="082e329b2b255ec547e24767cb5b2948">

<p>This event is emitted after a new connection has been successfully
handshaked. The argument is a instance of <a href="#tls_class_tls_tlssocket">tls.TLSSocket</a>. It has all the
common stream methods and events.

</p>
</div>

<div class="translate-section" data-hash="97730a28498c843eb9938d98d35a1583">

<p><code>socket.authorized</code> is a boolean value which indicates if the
client has verified by one of the supplied certificate authorities for the
server. If <code>socket.authorized</code> is false, then
<code>socket.authorizationError</code> is set to describe how authorization
failed. Implied but worth mentioning: depending on the settings of the TLS
server, you unauthorized connections may be accepted.
<code>socket.npnProtocol</code> is a string containing selected NPN protocol.
<code>socket.servername</code> is a string containing servername requested with
SNI.

</p>
</div>

<div class="translate-section" data-hash="1db79e530811fc519fbde11d3200bafe">

<h3>Event: &apos;clientError&apos;<span><a href="#tls_event_clienterror_304" id="tls_event_clienterror_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="8139ce949ad8455f5da31c91fdd32016">

<p><code>function (exception, tlsSocket) { }</code>

</p>
</div>

<div class="translate-section" data-hash="2bc80bc70b43e6df809e509fad118019">

<p>When a client connection emits an &apos;error&apos; event before secure connection is
established - it will be forwarded here.

</p>
</div>

<div class="translate-section" data-hash="7bde5932d423926521b06cbd0a1a846f">

<p><code>tlsSocket</code>就是<code>[tls.TLSSocket][]</code>，错误产生的地方。

</p>
</div>

<div class="translate-section" data-hash="5019fa242c7f729c02dfaee5c3e62c3b">

<h3>事件: &apos;newSession&apos;<span><a href="#tls_newsession_304" id="tls_newsession_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="ca82772d3d75501abb88c35d0325a741">

<p><code>function (sessionId, sessionData) { }</code>

</p>
</div>

<div class="translate-section" data-hash="c1121341b9b0b1de637a0bb7acc87abb">

<p>Emitted on creation of TLS session. May be used to store sessions in external
storage.

</p>
</div>

<div class="translate-section" data-hash="5a565597c6e0b4ba94f4fc31cd1670a4">

<p>NOTE: adding this event listener will have an effect only on connections
established after addition of event listener.

</p>
</div>

<div class="translate-section" data-hash="9452e4e080c7ea6f916f67b90da35091">

<h3>事件: &apos;resumeSession&apos;<span><a href="#tls_resumesession_304" id="tls_resumesession_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="7c294f88013f31eab5318761831dd366">

<p><code>function (sessionId, callback) { }</code>

</p>
</div>

<div class="translate-section" data-hash="85486c8e1da8a1ac227ca68e739f9434">

<p>Emitted when client wants to resume previous TLS session. Event listener may
perform lookup in external storage using given <code>sessionId</code>, and invoke
<code>callback(null, sessionData)</code> once finished. If session can&apos;t be resumed
(i.e. doesn&apos;t exist in storage) one may call <code>callback(null, null)</code>. Calling
<code>callback(err)</code> will terminate incoming connection and destroy socket.

</p>
</div>

<div class="translate-section" data-hash="5a565597c6e0b4ba94f4fc31cd1670a4">

<p>NOTE: adding this event listener will have an effect only on connections
established after addition of event listener.

</p>
</div>

<div class="translate-section" data-hash="ef484f68115b8f01ba61f449676de204">

<h3>server.listen(port, [host], [callback])<span><a href="#tls_server_listen_port_host_callback_304" id="tls_server_listen_port_host_callback_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="0a481e6541194801d2014b6095d0953d">

<p>Begin accepting connections on the specified <code>port</code> and <code>host</code>.  If the
<code>host</code> is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>).

</p>
</div>

<div class="translate-section" data-hash="cc006a56306659131437fef0e53317f7">

<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound.

</p>
</div>

<div class="translate-section" data-hash="da49dec74133e0d4348439b3b581f208">

<p>更多信息见<code>net.Server</code>。

</p>
</div>

<div class="translate-section" data-hash="9c571988346aff5c0f46e5a250ff9eb6">

<h3>server.close()<span><a href="#tls_server_close_304" id="tls_server_close_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="3346c75f394b6fc71db1f6eb4e0977be">

<p>Stops the server from accepting new connections. This function is
asynchronous, the server is finally closed when the server emits a <code>&apos;close&apos;</code>
event.

</p>
</div>

<div class="translate-section" data-hash="384a0012bb072a9b692a19e31455fc8f">

<h3>server.address()<span><a href="#tls_server_address_304" id="tls_server_address_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="b78e274f384dad79107bc28883ee3c73">

<p>Returns the bound address, the address family name and port of the
server as reported by the operating system.  See <a href="net.html#net_server_address">net.Server.address()</a> for
more information.

</p>
</div>

<div class="translate-section" data-hash="1f2083b6f8c1fed832e246955620eab5">

<h3>server.addContext(hostname, credentials)<span><a href="#tls_server_addcontext_hostname_credentials_304" id="tls_server_addcontext_hostname_credentials_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="ee6395eea66aafc979e1ee8de3291c4d">

<p>Add secure context that will be used if client request&apos;s SNI hostname is
matching passed <code>hostname</code> (wildcards can be used). <code>credentials</code> can contain
<code>key</code>, <code>cert</code> and <code>ca</code>.

</p>
</div>

<div class="translate-section" data-hash="a1729ebb5af5ad68678ff775c92a05de">

<h3>server.maxConnections<span><a href="#tls_server_maxconnections_304" id="tls_server_maxconnections_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="a06f729fe436969087cdabde0ee9fbde">

<p>Set this property to reject connections when the server&apos;s connection count
gets high.

</p>
</div>

<div class="translate-section" data-hash="49db72aa1abba4986962d84adecdf2e4">

<h3>server.connections<span><a href="#tls_server_connections_304" id="tls_server_connections_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="f4b5d98fd6e7acf826b418a00e477948">

<p>服务器的并发连接数.

</p>
</div>

<div class="translate-section" data-hash="a9a3ffc186a6dec558a77bcaddabdc0d">

<h2>类: CryptoStream<span><a href="#tls_cryptostream_304" id="tls_cryptostream_304">#</a></span></h2>
</div>

<div class="translate-section" data-hash="6b542b021eec46d9d0c2e9c51eb4275f">

<pre><code>稳定性: 0 - 已废弃。使用 tls.TLSSocket 替代。</code></pre>
</div>

<div class="translate-section" data-hash="788c070ad910ba7ebfce7613bb70a448">

<p>这是一个被加密的流。

</p>
</div>

<div class="translate-section" data-hash="1475725ecf4883e8b2ab866739062a66">

<h3>cryptoStream.bytesWritten<span><a href="#tls_cryptostream_byteswritten_304" id="tls_cryptostream_byteswritten_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="c3e09cfb2346dd9fe060cd71b3ad2bd0">

<p>A proxy to the underlying socket&apos;s bytesWritten accessor, this will return
the total bytes written to the socket, <em>including the TLS overhead</em>.

</p>
</div>

<div class="translate-section" data-hash="f49cedfdf1a25b85e777bf14b1381865">

<h2>Class: tls.TLSSocket<span><a href="#tls_class_tls_tlssocket_209" id="tls_class_tls_tlssocket_209">#</a></span></h2>
</div>

<div class="translate-section" data-hash="b1d3cadfff082c381b5fb7f294e60557">

<p>This is a wrapped version of <a href="net.html#net_class_net_socket">net.Socket</a> that does transparent encryption
of written data and all required TLS negotiation.

</p>
</div>

<div class="translate-section" data-hash="2ffc170c6763dc99bdc9f2e13d9191dc">

<p>This instance implements a duplex <a href="stream.html#stream_stream">Stream</a> interfaces.  It has all the
common stream methods and events.

</p>
</div>

<div class="translate-section" data-hash="54e79d8f825c8f9675a06ea6f0c91e39">

<h3>事件: &apos;secureConnect&apos;<span><a href="#tls_secureconnect_304" id="tls_secureconnect_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="77045f78ce7c61814a9b68f87037199b">

<p>This event is emitted after a new connection has been successfully handshaked.
The listener will be called no matter if the server&apos;s certificate was
authorized or not. It is up to the user to test <code>tlsSocket.authorized</code>
to see if the server certificate was signed by one of the specified CAs.
If <code>tlsSocket.authorized === false</code> then the error can be found in
<code>tlsSocket.authorizationError</code>. Also if NPN was used - you can check
<code>tlsSocket.npnProtocol</code> for negotiated protocol.

</p>
</div>

<div class="translate-section" data-hash="2520172b9e357cdc30235508ec85f587">

<h3>tlsSocket.authorized<span><a href="#tls_tlssocket_authorized_304" id="tls_tlssocket_authorized_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="3b22814050d7a1ad42014a3321e8c5ac">

<p>A boolean that is <code>true</code> if the peer certificate was signed by one of the
specified CAs, otherwise <code>false</code>

</p>
</div>

<div class="translate-section" data-hash="5b82d8a607f773b0915d002a67d24b6f">

<h3>tlsSocket.authorizationError<span><a href="#tls_tlssocket_authorizationerror_304" id="tls_tlssocket_authorizationerror_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="33f9a6af66ba4e919acc63e146d6f3b1">

<p>The reason why the peer&apos;s certificate has not been verified. This property
becomes available only when <code>tlsSocket.authorized === false</code>.

</p>
</div>

<div class="translate-section" data-hash="3ca263e36a43d7920f7c06705a74ba1c">

<h3>tlsSocket.getPeerCertificate()<span><a href="#tls_tlssocket_getpeercertificate_304" id="tls_tlssocket_getpeercertificate_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="27ec2a904e45c18a2075d95e8510f747">

<p>Returns an object representing the peer&apos;s certificate. The returned object has
some properties corresponding to the field of the certificate.

</p>
</div>

<div class="translate-section" data-hash="81eeab9506186e2dca8faefa78d54067">

<p>实例：

</p>
</div>

<div class="translate-section" data-hash="3b5121bb23864739ebfcd7cdc597cb50">

<pre><code>{ subject: 
   { C: &apos;UK&apos;,
     ST: &apos;Acknack Ltd&apos;,
     L: &apos;Rhys Jones&apos;,
     O: &apos;node.js&apos;,
     OU: &apos;Test TLS Certificate&apos;,
     CN: &apos;localhost&apos; },
  issuer: 
   { C: &apos;UK&apos;,
     ST: &apos;Acknack Ltd&apos;,
     L: &apos;Rhys Jones&apos;,
     O: &apos;node.js&apos;,
     OU: &apos;Test TLS Certificate&apos;,
     CN: &apos;localhost&apos; },
  valid_from: &apos;Nov 11 09:52:22 2009 GMT&apos;,
  valid_to: &apos;Nov  6 09:52:22 2029 GMT&apos;,
  fingerprint: &apos;2A:7A:C2:DD:E5:F9:CC:53:72:35:99:7A:02:5A:71:38:52:EC:8A:DF&apos; }</code></pre>
</div>

<div class="translate-section" data-hash="3c696c1b0863a0d7ae3370a0d53d3a38">

<p>如果节点没有提供证书, 它将返回 <code>null</code> 或者一个空对象.

</p>
</div>

<div class="translate-section" data-hash="fcd1474a6ef1904fe8bbdd9e98bbef7e">

<h3>tlsSocket.getCipher()<span><a href="#tls_tlssocket_getcipher_304" id="tls_tlssocket_getcipher_304">#</a></span></h3>
<p>返回一个对象，表示了当前连接的cipher名与SSL/TLS协议版本。

</p>
</div>

<div class="translate-section" data-hash="0e012c29b39ee4eefdc2572c80aa73b2">

<p>Example:
{ name: &apos;AES256-SHA&apos;, version: &apos;TLSv1/SSLv3&apos; }

</p>
</div>

<div class="translate-section" data-hash="fb7086021857eb797fb7837feed993cc">

<p>See SSL_CIPHER_get_name() and SSL_CIPHER_get_version() in
<a href="http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_CIPHERS">http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_CIPHERS</a> for more
information.

</p>
</div>

<div class="translate-section" data-hash="6aebf26a5c20151c1460dab53fee670d">

<h3>tlsSocket.renegotiate(options, callback)<span><a href="#tls_tlssocket_renegotiate_options_callback_304" id="tls_tlssocket_renegotiate_options_callback_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="92974a00c05e2ebd675be400cf160e1d">

<p>Initiate TLS renegotiation process. The <code>options</code> may contain the following
fields: <code>rejectUnauthorized</code>, <code>requestCert</code> (See <a href="#tls_tls_createserver_options_secureconnectionlistener">tls.createServer</a>
for details). <code>callback(err)</code> will be executed with <code>null</code> as <code>err</code>,
once the renegotiation is successfully completed.

</p>
</div>

<div class="translate-section" data-hash="25759b818389b8bf0faf2bac88557064">

<p>NOTE: Can be used to request peer&apos;s certificate after the secure connection
has been established.

</p>
</div>

<div class="translate-section" data-hash="81e3c0a8ac0f76de6eca77c8fb6a2de3">

<p>ANOTHER NOTE: When running as the server, socket will be destroyed
with an error after <code>handshakeTimeout</code> timeout.

</p>
</div>

<div class="translate-section" data-hash="5d3df9e17ca60b04844b3c918d24d497">

<h3>tlsSocket.address()<span><a href="#tls_tlssocket_address_304" id="tls_tlssocket_address_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="4c1be53de58495e9fb6e229548860f86">

<p>Returns the bound address, the address family name and port of the
underlying socket as reported by the operating system. Returns an
object with three properties, e.g.
<code>{ port: 12346, family: &apos;IPv4&apos;, address: &apos;127.0.0.1&apos; }</code>

</p>
</div>

<div class="translate-section" data-hash="5039928eec6dad1197c2da3834f884ee">

<h3>tlsSocket.remoteAddress<span><a href="#tls_tlssocket_remoteaddress_304" id="tls_tlssocket_remoteaddress_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="3875d73c871ccf8b6152db536146f839">

<p>远程IP地址的字符串表示。例如，<code>&apos;74.125.127.100&apos;</code>或 <code>&apos;2001:4860:a005::68&apos;</code>。

</p>
</div>

<div class="translate-section" data-hash="67693d1184bf4c7920ee5889bb87714e">

<h3>tlsSocket.remotePort<span><a href="#tls_tlssocket_remoteport_304" id="tls_tlssocket_remoteport_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="751ae8945ade1e8befb3ec862d6adf3a">

<p>远程端口的数值表示。例如， <code>443</code>。

</p>
</div>

<div class="translate-section" data-hash="6a17eb3a7201157bc6c3d2b89e9d0667">

<h3>tlsSocket.localAddress<span><a href="#tls_tlssocket_localaddress_304" id="tls_tlssocket_localaddress_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="c6f975d7c149827a134681157c4daa3c">

<p>本地IP地址的字符串表达。

</p>
</div>

<div class="translate-section" data-hash="c566329dd5f7bd371236b00e65b5ada7">

<h3>tlsSocket.localPort<span><a href="#tls_tlssocket_localport_304" id="tls_tlssocket_localport_304">#</a></span></h3>
</div>

<div class="translate-section" data-hash="64f28eee3970fa06e346bcf936e88710">

<p>本地端口的数值表示。

</p>
</div>

<div class="translate-section" data-hash="74a1cf52a8575492af1662567f712989">

</div>
          </div>
        </div>
    </div>
    <div id="footer">
        <a href="http://joyent.com" class="joyent-logo">Joyent</a>
        <ul class="clearfix">
            <li><a href="http://nodejs.org/">Node.js</a></li>
            <li><a href="http://nodejs.org/download/">Download</a></li>
            <li><a href="http://nodejs.org/about/">About</a></li>
            <li><a href="http://npmjs.org/">npm Registry</a></li>
            <li><a href="http://nodejs.org/api/">Docs</a></li>
            <li><a href="http://blog.nodejs.org">Blog</a></li>
            <li><a href="http://nodejs.org/community/">Community</a></li>
            <li><a href="http://nodejs.org/logos/">Logos</a></li>
            <li><a href="http://jobs.nodejs.org/">Jobs</a></li>
            <li><a href="http://twitter.com/nodejs" class="twitter">@nodejs</a></li>
        </ul>

        <p>Copyright <a href="http://joyent.com/">Joyent, Inc</a>, Node.js is a <a href="/trademark-policy.pdf">trademark</a> of Joyent, Inc. View <a href="https://raw.github.com/joyent/node/v0.10.18/LICENSE">license</a>.</p>
    </div>

  <script src="/public/api_assets/sh_main.js"></script>
  <script src="/public/api_assets/sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>
</body>
</html>

<!-- google analytics -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-26599868-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

<script src="/public/js/jquery.js"></script>
<script>
$('.translate-section').each(function () {
  var html = '<div class="op">' +
               '<button class="show-origin">显示原文</button>' +
               '<button class="btn btn-xs btn-info">其他翻译</button>' +
               '<button class="btn btn-xs btn-info">纠错</button>' +
              '</div>';
  $(this).prepend(html);
});

// 显示原文
$('.translate-section').delegate('.show-origin', 'click', function () {
  var $section = $(this).closest('.translate-section');
  var hash = $section.data('hash');
  $.get('/translate/get/origin', {hash: hash}, function (d) {
    if (d.error) return alert(d.error);

    $section.find('.origin').remove();
    $section.append('<div class="origin">' + d.html + '</div>');
    highlight(undefined, undefined, 'code');
  });
});
</script>