<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>加密（Crypto） Node.js v0.10.18 文档 中文版</title>
  <link rel="stylesheet" href="/public/api_assets/style.css">
  <link rel="stylesheet" href="/public/api_assets/sh.css">
  <link rel="canonical" href="http://nodejs.org/api/crypto.html">
</head>
<body class="alt apidoc" id="api-section-crypto">

    <div id="intro" class="interior">
        <a href="/api/" title="返回首页">
            <img id="logo" src="http://nodejs.org/images/logo-light.png" alt="node.js">
        </a>
    </div>
    <div id="content" class="clearfix">
        <div id="column2" class="interior">
            <ul>
                <li><a href="/api/" class="docs current">文档首页</a></li>
                <li><a href="http://nodejs.org/api/">英文版文档</a></li>
            </ul>
            <div style="margin-top:44px; font-size:12px;">
              <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh"><img alt="知识共享许可协议" style="border-width:0" src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh">知识共享署名-非商业性使用 3.0 未本地化版本许可协议</a>进行许可。
            </div>
        </div>

        <div id="column1" class="interior">
          <header>
            <h1>Node.js v0.10.18 手册 &amp; 文档</h1>
            <div id="gtoc">
              <p>
                <a href="index.html" name="toc">索引</a> |
                <a href="all.html">在单一页面中浏览</a> |
                <a href="crypto.json">JSON格式</a>
              </p>
            </div>
            <hr>
          </header>

          <div id="toc">
            <h2>目录</h2>
            <ul>
<li><a href="#crypto_crypto_938">加密（Crypto）</a><ul>
<li><a href="#crypto_crypto_getciphers_938">crypto.getCiphers()</a></li>
<li><a href="#crypto_crypto_gethashes_938">crypto.getHashes()</a></li>
<li><a href="#crypto_crypto_createcredentials_details_938">crypto.createCredentials(details)</a></li>
<li><a href="#crypto_crypto_createhash_algorithm_938">crypto.createHash(algorithm)</a></li>
<li><a href="#crypto_hash_938">类: Hash</a><ul>
<li><a href="#crypto_hash_update_data_input_encoding_938">hash.update(data, [input_encoding])</a></li>
<li><a href="#crypto_hash_digest_encoding_938">hash.digest([encoding])</a></li>
</ul>
</li>
<li><a href="#crypto_crypto_createhmac_algorithm_key_938">crypto.createHmac(algorithm, key)</a></li>
<li><a href="#crypto_class_hmac_938">Class: Hmac</a><ul>
<li><a href="#crypto_hmac_update_data_938">hmac.update(data)</a></li>
<li><a href="#crypto_hmac_digest_encoding_938">hmac.digest([encoding])</a></li>
</ul>
</li>
<li><a href="#crypto_crypto_createcipher_algorithm_password_938">crypto.createCipher(algorithm, password)</a></li>
<li><a href="#crypto_crypto_createcipheriv_algorithm_key_iv_938">crypto.createCipheriv(algorithm, key, iv)</a></li>
<li><a href="#crypto_class_cipher_938">Class: Cipher</a><ul>
<li><a href="#crypto_cipher_update_data_input_encoding_output_encoding_938">cipher.update(data, [input_encoding], [output_encoding])</a></li>
<li><a href="#crypto_cipher_final_output_encoding_938">cipher.final([output_encoding])</a></li>
<li><a href="#crypto_cipher_setautopadding_auto_padding_true_938">cipher.setAutoPadding(auto_padding=true)</a></li>
</ul>
</li>
<li><a href="#crypto_crypto_createdecipher_algorithm_password_938">crypto.createDecipher(algorithm, password)</a></li>
<li><a href="#crypto_crypto_createdecipheriv_algorithm_key_iv_938">crypto.createDecipheriv(algorithm, key, iv)</a></li>
<li><a href="#crypto_class_decipher_938">Class: Decipher</a><ul>
<li><a href="#crypto_decipher_update_data_input_encoding_output_encoding_938">decipher.update(data, [input_encoding], [output_encoding])</a></li>
<li><a href="#crypto_decipher_final_output_encoding_938">decipher.final([output_encoding])</a></li>
<li><a href="#crypto_decipher_setautopadding_auto_padding_true_938">decipher.setAutoPadding(auto_padding=true)</a></li>
</ul>
</li>
<li><a href="#crypto_crypto_createsign_algorithm_938">crypto.createSign(algorithm)</a></li>
<li><a href="#crypto_class_sign_938">Class: Sign</a><ul>
<li><a href="#crypto_sign_update_data_938">sign.update(data)</a></li>
<li><a href="#crypto_sign_sign_private_key_output_format_938">sign.sign(private_key, [output_format])</a></li>
</ul>
</li>
<li><a href="#crypto_crypto_createverify_algorithm_938">crypto.createVerify(algorithm)</a></li>
<li><a href="#crypto_class_verify_938">Class: Verify</a><ul>
<li><a href="#crypto_verifier_update_data_938">verifier.update(data)</a></li>
<li><a href="#crypto_verifier_verify_object_signature_signature_format_938">verifier.verify(object, signature, [signature_format])</a></li>
</ul>
</li>
<li><a href="#crypto_crypto_creatediffiehellman_prime_length_938">crypto.createDiffieHellman(prime_length)</a></li>
<li><a href="#crypto_crypto_creatediffiehellman_prime_encoding_938">crypto.createDiffieHellman(prime, [encoding])</a></li>
<li><a href="#crypto_class_diffiehellman_938">Class: DiffieHellman</a><ul>
<li><a href="#crypto_diffiehellman_generatekeys_encoding_938">diffieHellman.generateKeys([encoding])</a></li>
<li><a href="#crypto_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding_938">diffieHellman.computeSecret(other_public_key, [input_encoding], [output_encoding])</a></li>
<li><a href="#crypto_diffiehellman_getprime_encoding_938">diffieHellman.getPrime([encoding])</a></li>
<li><a href="#crypto_diffiehellman_getgenerator_encoding_938">diffieHellman.getGenerator([encoding])</a></li>
<li><a href="#crypto_diffiehellman_getpublickey_encoding_938">diffieHellman.getPublicKey([encoding])</a></li>
<li><a href="#crypto_diffiehellman_getprivatekey_encoding_938">diffieHellman.getPrivateKey([encoding])</a></li>
<li><a href="#crypto_diffiehellman_setpublickey_public_key_encoding_938">diffieHellman.setPublicKey(public_key, [encoding])</a></li>
<li><a href="#crypto_diffiehellman_setprivatekey_private_key_encoding_938">diffieHellman.setPrivateKey(private_key, [encoding])</a></li>
</ul>
</li>
<li><a href="#crypto_crypto_getdiffiehellman_group_name_938">crypto.getDiffieHellman(group_name)</a></li>
<li><a href="#crypto_crypto_pbkdf2_password_salt_iterations_keylen_callback_938">crypto.pbkdf2(password, salt, iterations, keylen, callback)</a></li>
<li><a href="#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_938">crypto.pbkdf2Sync(password, salt, iterations, keylen)</a></li>
<li><a href="#crypto_crypto_randombytes_size_callback_938">crypto.randomBytes(size, [callback])</a></li>
<li><a href="#crypto_crypto_pseudorandombytes_size_callback_938">crypto.pseudoRandomBytes(size, [callback])</a></li>
<li><a href="#crypto_crypto_default_encoding_938">crypto.DEFAULT_ENCODING</a></li>
<li><a href="#crypto_recent_api_changes_938">Recent API Changes</a></li>
</ul>
</li>
</ul>

          </div>

          <div id="apicontent">
            <div class="translate-section" data-hash="775a74eb860b3310e171801622f960e8">

<h1>加密（Crypto）<span><a href="#crypto_crypto_938" id="crypto_crypto_938">#</a></span></h1>
</div>

<div class="translate-section" data-hash="e53b8b3019b2008d53a716f2c31fb12c">

<pre><code>稳定度: 2 - 不稳定；正在讨论未来版本的API变动。会尽量减少重大变动的发生。详见下文。</code></pre>
</div>

<div class="translate-section" data-hash="b2617ab04b8de88a16947215f986445b">

<p>使用 <code>require(&apos;crypto&apos;)</code> 来调用该模块。

</p>
</div>

<div class="translate-section" data-hash="795a972e1f81691825079652f276000b">

<p>crypto模块提供在HTTPS或HTTP连接中封装安全凭证的方法.

</p>
</div>

<div class="translate-section" data-hash="f3e6a55a49628baffc3127a24a0d57c9">

<p>它提供OpenSSL中的一系列哈希方法，包括hmac、cipher、decipher、签名和验证等方法的封装。

</p>
</div>

<div class="translate-section" data-hash="0e83303b91d1bbfc207d07efed663386">

<h2>crypto.getCiphers()<span><a href="#crypto_crypto_getciphers_938" id="crypto_crypto_getciphers_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="a89fc2852cd2e83a42041ac7cb8afd5a">

<p>返回一个数组，包含支持的加密算法的名字。

</p>
</div>

<div class="translate-section" data-hash="81eeab9506186e2dca8faefa78d54067">

<p>实例：

</p>
</div>

<div class="translate-section" data-hash="ff8d4cfa42a197bfe3b1f73661eee7eb">

<pre><code>var ciphers = crypto.getCiphers();
console.log(ciphers); // [&apos;AES-128-CBC&apos;, &apos;AES-128-CBC-HMAC-SHA1&apos;, ...]</code></pre>
</div>

<div class="translate-section" data-hash="9aa8dd51e2424f12a603f18ef90c4d8c">

<h2>crypto.getHashes()<span><a href="#crypto_crypto_gethashes_938" id="crypto_crypto_gethashes_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="ebaf3064e8e7fff1f3f0c4b84b8c19fe">

<p>返回一个包含所支持的哈希算法的数组。

</p>
</div>

<div class="translate-section" data-hash="81eeab9506186e2dca8faefa78d54067">

<p>实例：

</p>
</div>

<div class="translate-section" data-hash="5712ac4a9e7ff9809b823b2c8797a19d">

<pre><code>var hashes = crypto.getHashes();
console.log(hashes); // [&apos;sha&apos;, &apos;sha1&apos;, &apos;sha1WithRSAEncryption&apos;, ...]</code></pre>
</div>

<div class="translate-section" data-hash="4c351c73e5e4a74ed67c5591972ed0f5">

<h2>crypto.createCredentials(details)<span><a href="#crypto_crypto_createcredentials_details_938" id="crypto_crypto_createcredentials_details_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="15afd6793ffd679466fd3d54f8d5c867">

<p>创建一个加密凭证对象，接受一个可选的参数对象：

</p>
</div>

<div class="translate-section" data-hash="1c2f0d670be0a5899138343f1422ab04">

<ul>
<li><code>pfx</code> : 一个字符串或者buffer对象，代表经PFX或者PKCS12编码产生的私钥、证书以及CA证书</li>
<li><code>key</code> : 一个字符串，代表经PEM编码产生的私钥</li>
<li><code>passphrase</code> : 私钥或者pfx的密码</li>
<li><code>cert</code> : 一个字符串，代表经PEM编码产生的证书</li>
<li><code>ca</code> : 一个字符串或者字符串数组，表示可信任的经PEM编码产生的CA证书列表</li>
<li><code>crl</code> : 一个字符串或者字符串数组，表示经PEM编码产生的CRL（证书吊销列表 Certificate Revocation List）</li>
<li><code>ciphers</code>: 一个字符串，表示需要使用或者排除的加密算法
可以在
<a href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>
查看更多关于加密算法格式的资料。</li>
</ul>
</div>

<div class="translate-section" data-hash="ca6125ef195b2cf4fadf2afea483b33e">

<p>如果没有指定<code>ca</code>，node.js会使用<a href="http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>提供的公共可信任的CA列表。

</p>
</div>

<div class="translate-section" data-hash="7ff3b4843f99da28e10387128c1ecaef">

<h2>crypto.createHash(algorithm)<span><a href="#crypto_crypto_createhash_algorithm_938" id="crypto_crypto_createhash_algorithm_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="4b0546b5631e50c7aaffada05a69ab7a">

<p>创建并返回一个哈希对象，一个使用所给算法的用于生成摘要的加密哈希。

</p>
</div>

<div class="translate-section" data-hash="9331eb1ed60a2e9503205dbf7aa63ccd">

<p><code>algorithm</code> 取决与平台上所安装的 OpenSSL 版本所支持的算法。比如 <code>&apos;sha1&apos;</code>、<code>&apos;md5&apos;</code>、<code>&apos;sha256&apos;</code>、<code>&apos;sha512&apos;</code> 等等。在最近的发行版本中，<code>openssl list-message-digest-algorithms</code> 会显示可用的摘要算法。

</p>
</div>

<div class="translate-section" data-hash="60ebc5900d51c78f0bcfbd60252afa0e">

<p>例子：这段程序会计算出一个文件的 sha1 摘要值。

</p>
</div>

<div class="translate-section" data-hash="b96ef0c48b19a9247395e347567b2fa5">

<pre><code>s.on(&apos;end&apos;, function() {
  var d = shasum.digest(&apos;hex&apos;);
  console.log(d + &apos;  &apos; + filename);
});</code></pre>
</div>

<div class="translate-section" data-hash="85abfbdaada5e14670608ed6480a9102">

<h2>类: Hash<span><a href="#crypto_hash_938" id="crypto_hash_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="357840b743ca47220b9422da4c5df846">

<p>创建数据哈希摘要的类。

</p>
</div>

<div class="translate-section" data-hash="28b2dcbbc5599d6bf1ff3154f9fb3e59">

<p>它是一个既可读又可写的<a href="stream.html">流</a>。所写入的数据会被用作计算哈希。当流的可写端终止后，使用 <code>read()</code> 方法来获取计算得的哈希摘要。同时也支持旧有的 <code>update</code> 和 <code>digest</code> 方法。

</p>
</div>

<div class="translate-section" data-hash="d115ca269c8615d37ce93bda91e5a29a">

<p>通过 <code>crypto.createHash</code> 返回。

</p>
</div>

<div class="translate-section" data-hash="dc323ebf6468dda3ea01f19119694b88">

<h3>hash.update(data, [input_encoding])<span><a href="#crypto_hash_update_data_input_encoding_938" id="crypto_hash_update_data_input_encoding_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="9a73cdd718b00dd8401d4ed9d92c9bf4">

<p>通过提供的数据更新哈希对象，可以通过<code>input_encoding</code>指定编码为<code>&apos;utf8&apos;</code>、<code>&apos;ascii&apos;</code>或者
<code>&apos;binary&apos;</code>。如果没有指定编码，将作为二进制数据（buffer）处理。

</p>
</div>

<div class="translate-section" data-hash="85dbfd72e811b71440bab55ef3f00319">

<p>因为它是流式数据，所以可以使用不同的数据调用很多次。

</p>
</div>

<div class="translate-section" data-hash="761ea6e786e24433d620da3cc1aa31fe">

<h3>hash.digest([encoding])<span><a href="#crypto_hash_digest_encoding_938" id="crypto_hash_digest_encoding_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="0dea43e4131634883d6ad50dfbd80d04">

<p>计算传入的所有数据的摘要值。<code>encoding</code>可以是<code>&apos;hex&apos;</code>、<code>&apos;binary&apos;</code>或者<code>&apos;base64&apos;</code>，如果没有指定，会返回一个buffer对象。

</p>
</div>

<div class="translate-section" data-hash="04cb1b7ba6d909940690eee3bd4d7702">

<p>注意：<code>hash</code> 对象在 <code>digest()</code> 方法被调用后将不可用。

</p>
</div>

<div class="translate-section" data-hash="1743278e9bc126db8418ab01aacb0e32">

<h2>crypto.createHmac(algorithm, key)<span><a href="#crypto_crypto_createhmac_algorithm_key_938" id="crypto_crypto_createhmac_algorithm_key_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="21688c52fb4def768dbd1d4696ff566a">

<p>创建并返回一个hmac对象，也就是通过给定的加密算法和密钥生成的加密图谱（cryptographic）。

</p>
</div>

<div class="translate-section" data-hash="21ab2651aabe9098c12e5980c2656da9">

<p>它是一个既可读又可写的流（<a href="stream.html">stream</a>）。写入的数据会被用于计算hmac。写入终止后，可以使用<code>read()</code>方法获取计算后的摘要值。之前版本的<code>update</code>和<code>digest</code>方法仍然支持。

</p>
</div>

<div class="translate-section" data-hash="cd630e4d9932118b0922734fa537afe7">

<p><code>algorithm</code>在OpenSSL支持的算法列表中被抛弃了——见上方createHash部分。<code>key</code>是hmac算法用到的密钥。

</p>
</div>

<div class="translate-section" data-hash="cb2b4f516b66d2abba7e534f015afbc6">

<h2>Class: Hmac<span><a href="#crypto_class_hmac_938" id="crypto_class_hmac_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="9e4db680c1c412e6a47b76e1b8396e51">

<p>用于创建hmac加密图谱（cryptographic）的类。

</p>
</div>

<div class="translate-section" data-hash="1dd14ff007ac975bb53cd21ca134b9a4">

<p>由<code>crypto.createHmac</code>返回。

</p>
</div>

<div class="translate-section" data-hash="b7b6637a1f47138c9acdfdfbf3e985cd">

<h3>hmac.update(data)<span><a href="#crypto_hmac_update_data_938" id="crypto_hmac_update_data_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="05a8851f0aaead29cf5113733cf07e3b">

<p>通过提供的数据更新hmac对象。因为它是流式数据，所以可以使用新数据调用很多次。

</p>
</div>

<div class="translate-section" data-hash="aa3f0a3a7e67515ccd8b21b2cdfef21a">

<h3>hmac.digest([encoding])<span><a href="#crypto_hmac_digest_encoding_938" id="crypto_hmac_digest_encoding_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="446ebdb595866ea43e0de486c4182812">

<p>计算传入的所有数据的hmac摘要值。<code>encoding</code>可以是<code>&apos;hex&apos;</code>、<code>&apos;binary&apos;</code>或者<code>&apos;base64&apos;</code>，如果没有指定，会返回一个buffer对象。

</p>
</div>

<div class="translate-section" data-hash="9100441d876c4c0a209ee7326b28e424">

<p>注意： <code>hmac</code>对象在调用<code>digest()</code>之后就不再可用了。

</p>
</div>

<div class="translate-section" data-hash="b31b04d5c880f6dcd7a62b4498f4ec44">

<h2>crypto.createCipher(algorithm, password)<span><a href="#crypto_crypto_createcipher_algorithm_password_938" id="crypto_crypto_createcipher_algorithm_password_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="ccc82df63a307f0d774d4dedd90aeea1">

<p>用给定的算法和密码，创建并返回一个cipher加密算法的对象。（译者：cipher 就是加密算法的意思， ssl 的 cipher 主要是对称加密算法和不对称加密算法的组合。）

</p>
</div>

<div class="translate-section" data-hash="dfd395d0e123dc329f03c0008f579919">

<p><code>algorithm</code>算法是依赖OpenSSL库的, 例如: <code>&apos;aes192&apos;</code>算法等。在最近发布的版本， 执行命令 <code>openssl list-cipher-algorithms</code> 就会显示出所有可用的加密算法，<code>password</code>是用来派生key和IV的，它必须是一个 <code>&apos;binary&apos;</code> 2进制格式的字符串或者是一个<a href="buffer.html">buffer</a>。（译者：key表示密钥，IV表示向量在加密过程和解密过程都要使用）

</p>
</div>

<div class="translate-section" data-hash="28b2dcbbc5599d6bf1ff3154f9fb3e59">

<p>它是一个既可读又可写的<a href="stream.html">流</a>。所写入的数据会被用作计算哈希。当流的可写端终止后，使用 <code>read()</code> 方法来获取计算得的哈希摘要。同时也支持旧有的 <code>update</code> 和 <code>digest</code> 方法。

</p>
</div>

<div class="translate-section" data-hash="f67a61ca46752f72e464a5cbfb111f21">

<h2>crypto.createCipheriv(algorithm, key, iv)<span><a href="#crypto_crypto_createcipheriv_algorithm_key_iv_938" id="crypto_crypto_createcipheriv_algorithm_key_iv_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="56ee5152a3f3b99a034cb039c7813b43">

<p>用给定的算法、密码和向量，创建并返回一个cipher加密算法的对象。

</p>
</div>

<div class="translate-section" data-hash="2bc5e1b118d89b5225c531fe210c676e">

<p><code>algorithm</code>算法和<code>createCipher()</code> 方法的参数相同.  <code>key</code>密钥是一个被算法使用的原始密钥，<code>iv</code>是一个<a href="http://en.wikipedia.org/wiki/Initialization_vector">初始化向量</a>。

</p>
</div>

<div class="translate-section" data-hash="dac910eb9ba8fe6cbb47fe96af82a248">

<p><code>key</code>密钥和<code>iv</code>向量必须是<code>&apos;binary&apos;</code>2进制格式的字符串或<a href="buffer.html">buffers</a>.

</p>
</div>

<div class="translate-section" data-hash="8c8bc29c2d777f08810bf47d479395ee">

<h2>Class: Cipher<span><a href="#crypto_class_cipher_938" id="crypto_class_cipher_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="c928f6fe8035ccf3c653ce4fbb127422">

<p>这个类是用来加密数据的。

</p>
</div>

<div class="translate-section" data-hash="2238270e065cb6499b5fa1243ef91497">

<p>这个类由 <code>crypto.createCipher</code> 和 <code>crypto.createCipheriv</code> 返回。

</p>
</div>

<div class="translate-section" data-hash="eda854407f6ccece26731dcc0900e910">

<p>Cipher加密对象是 <a href="stream.html">streams</a>，他是具有 readable 可读和 writable 可写的。写入的纯文本数据是用来在可读流一侧加密数据的。
以前版本的<code>update</code> 和<code>final</code>方法也还是支持的。

</p>
</div>

<div class="translate-section" data-hash="e0979b035c19eca4bb42ea0433082429">

<h3>cipher.update(data, [input_encoding], [output_encoding])<span><a href="#crypto_cipher_update_data_input_encoding_output_encoding_938" id="crypto_cipher_update_data_input_encoding_output_encoding_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="25430feedbe7c348741052721565cff2">

<p>用<code>data</code>参数更新cipher加密对象, 它的编码<code>input_encoding</code>必须是下列给定编码的 <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> or <code>&apos;binary&apos;</code> 中一种。如果没有编码参数，那么打他参数必须是一个buffer。

</p>
</div>

<div class="translate-section" data-hash="4a2f589a49e824a4168f0eb91eb8204e">

<p>参数 <code>output_encoding</code>输出编码指定了加密数据的输出格式，可以是<code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> 或者<code>&apos;hex&apos;</code>，如果没有提供这个参数，buffer将会返回。

</p>
</div>

<div class="translate-section" data-hash="3d7e8eb745df97081683fdc6081d7798">

<p>返回加密内容，并且Returns the enciphered contents, 用新数据作为流的话，它可以被调用多次。

</p>
</div>

<div class="translate-section" data-hash="0248eb7f7f486173d69c678e2d6c7953">

<h3>cipher.final([output_encoding])<span><a href="#crypto_cipher_final_output_encoding_938" id="crypto_cipher_final_output_encoding_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="0fb4ad6b7026ac5125a5c12c51b180b6">

<p>返回剩余的加密内容，<code>output_encoding</code>为<code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> 或 <code>&apos;hex&apos;</code>中的任意一个。 如果没有提供编码格式，则返回一个buffer对象。

</p>
</div>

<div class="translate-section" data-hash="760742a0efef1845ea525cc7baf72e69">

<p>注: 调用<code>final()</code>函数后<code>cipher</code> 对象不能被使用。

</p>
</div>

<div class="translate-section" data-hash="de1df0008ad279eba6bad933cfdca7db">

<h3>cipher.setAutoPadding(auto_padding=true)<span><a href="#crypto_cipher_setautopadding_auto_padding_true_938" id="crypto_cipher_setautopadding_auto_padding_true_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="36a8f0abf61e56eaf9d31d5d1a3936f7">

<p>对于将输入数据自动填充到块大小的功能，你可以将其禁用。如果<code>auto_padding</code>是false， 那么整个输入数据的长度必须是加密器的块大小的整倍数，否则<code>final</code>会失败。这对非标准的填充很有用，例如使用<code>0x0</code>而不是PKCS的填充。这个函数必须在<code>cipher.final</code>之前调用。

</p>
</div>

<div class="translate-section" data-hash="a48b7b168cff7477c4a5e72a91034ffb">

<h2>crypto.createDecipher(algorithm, password)<span><a href="#crypto_crypto_createdecipher_algorithm_password_938" id="crypto_crypto_createdecipher_algorithm_password_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="cac01c01866503a9fbca9d5fdcc69d23">

<p>根据给定的算法和密钥，创建并返回一个解密器对象。这是上述<a href="#crypto_crypto_createcipher_algorithm_password">createCipher()</a>的一个镜像。

</p>
</div>

<div class="translate-section" data-hash="6b95b405e78b1688f100abd75f6e83f7">

<h2>crypto.createDecipheriv(algorithm, key, iv)<span><a href="#crypto_crypto_createdecipheriv_algorithm_key_iv_938" id="crypto_crypto_createdecipheriv_algorithm_key_iv_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="5f097dd1e3e48a4b48d83fa02f6641ec">

<p>Creates and returns a decipher object, with the given algorithm, key
and iv.  This is the mirror of the <a href="#crypto_crypto_createcipheriv_algorithm_key_iv">createCipheriv()</a> above.
根据给定的算法，密钥和初始化向量，创建并返回一个解密器对象。这是上述<a href="#crypto_crypto_createcipheriv_algorithm_key_iv">createCipheriv()</a>的一个镜像。


</p>
</div>

<div class="translate-section" data-hash="96743970747c509bbb3786e96f07be3e">

<h2>Class: Decipher<span><a href="#crypto_class_decipher_938" id="crypto_class_decipher_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="037e006fe05755fc391c7b3d5dedf394">

<p>解密数据的类。

</p>
</div>

<div class="translate-section" data-hash="d4d3134d0ab02c7d94ac512be8f256fa">

<p>由<code>crypto.createDecipher</code>和<code>crypto.createDecipheriv</code>返回。

</p>
</div>

<div class="translate-section" data-hash="f8ac0ac0f44d2e73afa2210490b3eddd">

<p>解密器对象是可读写的<a href="stream.html">流</a>对象。用被写入的加密数据生成可读的平文数据。解码器对象也支持The legacy <code>update</code>和
<code>final</code>函数。

</p>
</div>

<div class="translate-section" data-hash="b9553bf6ec00e29b3464163a06015e6a">

<h3>decipher.update(data, [input_encoding], [output_encoding])<span><a href="#crypto_decipher_update_data_input_encoding_output_encoding_938" id="crypto_decipher_update_data_input_encoding_output_encoding_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="94d9e4b52ae6f9aaae66f7fb5b1c842b">

<p>用<code>data</code>来更新解密器，其中<code>data</code>以<code>&apos;binary&apos;</code>,
<code>&apos;base64&apos;</code> 或 <code>&apos;hex&apos;</code>进行编码。如果没有指明编码方式，则默认<code>data</code>是一个buffer对象。

</p>
</div>

<div class="translate-section" data-hash="476fc56f5e15d3ac458c841fd2641b37">

<p><code>output_decoding</code>指明了用以下哪种编码方式返回解密后的平文：<code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> 或 <code>&apos;utf8&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。

</p>
</div>

<div class="translate-section" data-hash="49f859fbfac86ec0600fc29d35063151">

<h3>decipher.final([output_encoding])<span><a href="#crypto_decipher_final_output_encoding_938" id="crypto_decipher_final_output_encoding_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="c869662f3b159fad3481ad2466e1915e">

<p>返回剩余的加密内容，<code>output_encoding</code>为<code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> 或 <code>&apos;utf8&apos;</code>中的任意一个。如果没有指明编码方式，则返回一个buffer对象。

</p>
</div>

<div class="translate-section" data-hash="5e32cfd17658327cb61c6c10e8bf1a96">

<p>注: 调用<code>final()</code>函数后不能使用<code>decipher</code> 对象。

</p>
</div>

<div class="translate-section" data-hash="a82641cfaf452ba4043e63a96d22340f">

<h3>decipher.setAutoPadding(auto_padding=true)<span><a href="#crypto_decipher_setautopadding_auto_padding_true_938" id="crypto_decipher_setautopadding_auto_padding_true_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="54770bafc5c5b0cb4d3cb5d0d4c22e48">

<p>如果数据以非标准的块填充方式被加密，那么你可以禁用自动填充来防止<code>decipher.final</code>对数据进行检查和移除。这只有在输入数据的长度是加密器块大小的整倍数时才有效。这个函数必须在将数据流传递给<code>decipher.update</code>之前调用。

</p>
</div>

<div class="translate-section" data-hash="2ab8765eb4ee901b2d72a3ef326ba94c">

<h2>crypto.createSign(algorithm)<span><a href="#crypto_crypto_createsign_algorithm_938" id="crypto_crypto_createsign_algorithm_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="29029e9d7ddc68047f19e5ebc27cf5fe">

<p>根据给定的算法，创建并返回一个signing对象。在最近的OpenSSL发布版本中，<code>openssl list-public-key-algorithms</code>会列出可用的签名算法，例如<code>&apos;RSA-SHA256&apos;</code>。

</p>
</div>

<div class="translate-section" data-hash="d4163c63cd2e8859b71d34d2a59a66cf">

<h2>Class: Sign<span><a href="#crypto_class_sign_938" id="crypto_class_sign_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="d597dca33327b356e48e49022c9ed56e">

<p>生成数字签名的类

</p>
</div>

<div class="translate-section" data-hash="a1bab1663bf980c288515ec577b50e43">

<p>由<code>crypto.createSign</code>返回。

</p>
</div>

<div class="translate-section" data-hash="57893bf1d92854c1f6b9c890aaee29e2">

<p>Sign对象是可写的<a href="stream.html">流</a>对象。被写入的数据用来生成数字签名。当所有的数据都被写入后，<code>sign</code> 函数会返回数字签名。Sign对象也支持The legacy
<code>update</code>函数。

</p>
</div>

<div class="translate-section" data-hash="b7a9bf3e65b1266ddd6c624c1d5ad2bb">

<h3>sign.update(data)<span><a href="#crypto_sign_update_data_938" id="crypto_sign_update_data_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="5dc19e92b06ba3cb421a176423c8938b">

<p>用<code>data</code>来更新sign对象。 This can be called many times
with new data as it is streamed.

</p>
</div>

<div class="translate-section" data-hash="8aa13d8fb315cb887e7bc0280a3359c7">

<h3>sign.sign(private_key, [output_format])<span><a href="#crypto_sign_sign_private_key_output_format_938" id="crypto_sign_sign_private_key_output_format_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="def9956b56bb8d871ae2d308261f40e2">

<p>根据所有传送给sign的更新数据来计算电子签名。<code>private_key</code>是一个包含了签名私钥的字符串，而该私钥是用PEM编码的。

</p>
</div>

<div class="translate-section" data-hash="153c112cba73841335d90f025b03cdb8">

<p>返回一个数字签名，该签名的格式可以是<code>&apos;binary&apos;</code>,
<code>&apos;hex&apos;</code>或 <code>&apos;base64&apos;</code>. 如果没有指明编码方式，则返回一个buffer对象。

</p>
</div>

<div class="translate-section" data-hash="84cdb92790bc4fee1c297a20f4dc3c2d">

<p>注：调用<code>sign()</code>后不能使用<code>sign</code>对象。

</p>
</div>

<div class="translate-section" data-hash="b707ccffb014ce3faa393fe18b20a411">

<h2>crypto.createVerify(algorithm)<span><a href="#crypto_crypto_createverify_algorithm_938" id="crypto_crypto_createverify_algorithm_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="e79d5815b9398ba87b6d1500beee4bda">

<p>根据指明的算法，创建并返回一个验证器对象。这是上述签名器对象的镜像。

</p>
</div>

<div class="translate-section" data-hash="84cad14f6a501e1740f547d8cac89edd">

<h2>Class: Verify<span><a href="#crypto_class_verify_938" id="crypto_class_verify_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="fe0f738bcd1e374ec4bc9c5b7dc9a10c">

<p>用来验证数字签名的类。

</p>
</div>

<div class="translate-section" data-hash="e851a8b1247a66e0720d840c15cca92d">

<p>由 <code>crypto.createVerify</code>返回。

</p>
</div>

<div class="translate-section" data-hash="85f1f64e91b96453c94609f8fa6a8a57">

<p>验证器对象是可写的<a href="stream.html">流</a>对象.  被写入的数据会被用来验证提供的数字签名。在所有的数据被写入后，如果提供的数字签名有效，<code>verify</code>函数会返回真。验证器对象也支持 The legacy <code>update</code>函数。

</p>
</div>

<div class="translate-section" data-hash="32cef30126f149dcdaac652f37216628">

<h3>verifier.update(data)<span><a href="#crypto_verifier_update_data_938" id="crypto_verifier_update_data_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="686b1ef3fe058b6ab0c9814f2cb88edb">

<p>用数据更新验证器对象。This can be called many times
with new data as it is streamed.

</p>
</div>

<div class="translate-section" data-hash="c76f59a76c00b3e5b04dc6345f223571">

<h3>verifier.verify(object, signature, [signature_format])<span><a href="#crypto_verifier_verify_object_signature_signature_format_938" id="crypto_verifier_verify_object_signature_signature_format_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="a10407e52ac2a5a7e019e1b87d4bd940">

<p>用<code>object</code>和<code>signature</code>来验证被签名的数据。
<code>object</code>是一个字符串，这个字符串包含了一个被PEM编码的对象，这个对象可以是RSA公钥，DSA公钥或者X.509 证书。
<code>signature</code>是之前计算出来的数字签名，其中的 <code>signature_format</code>可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>.
如果没有指明编码方式，那么默认是一个buffer对象。

</p>
</div>

<div class="translate-section" data-hash="cc2fdbc5d277a0f87888d8f32f1aa199">

<p>根据数字签名对于数据和公钥的有效性，返回true或false。

</p>
</div>

<div class="translate-section" data-hash="a5dbf751e88dbd799de19ae272a4c1fc">

<p>注: 调用<code>verify()</code>函数后不能使用<code>verifier</code>对象。

</p>
</div>

<div class="translate-section" data-hash="6db56ce6ec7dd5937a545b8d82ee1796">

<h2>crypto.createDiffieHellman(prime_length)<span><a href="#crypto_crypto_creatediffiehellman_prime_length_938" id="crypto_crypto_creatediffiehellman_prime_length_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="42044d1839ff5f4ba56af6f43a0de50c">

<p>创建一个迪菲－赫尔曼密钥交换(Diffie-Hellman key exchange)对象，并根据给定的位长度生成一个质数。所用的生成器是<code>s</code>。

</p>
</div>

<div class="translate-section" data-hash="200d8ecd5a35e2c4204d4dc596167234">

<h2>crypto.createDiffieHellman(prime, [encoding])<span><a href="#crypto_crypto_creatediffiehellman_prime_encoding_938" id="crypto_crypto_creatediffiehellman_prime_encoding_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="b1a034533c515cd1eb571d2884f349f3">

<p>根据给定的质数创建一个迪菲－赫尔曼密钥交换(Diffie-Hellman key exchange)对象。
所用的生成器是<code>2</code>。编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>或
<code>&apos;base64&apos;</code>。如果没有指明编码方式，则默认是一个buffer对象。

</p>
</div>

<div class="translate-section" data-hash="2341b637f736ca7e1c1f680394afbf79">

<h2>Class: DiffieHellman<span><a href="#crypto_class_diffiehellman_938" id="crypto_class_diffiehellman_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="79484424e9d80d14d26e219895b8e974">

<p>创建迪菲－赫尔曼密钥交换(Diffie-Hellman key exchanges)的类。

</p>
</div>

<div class="translate-section" data-hash="45e4d12e05dda0964305d13f302a1a09">

<p>由<code>crypto.createDiffieHellman</code>返回。

</p>
</div>

<div class="translate-section" data-hash="14ed425307b527c747d5057919747b34">

<h3>diffieHellman.generateKeys([encoding])<span><a href="#crypto_diffiehellman_generatekeys_encoding_938" id="crypto_diffiehellman_generatekeys_encoding_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="521ae16255374b30d80808398b9e051b">

<p>生成迪菲－赫尔曼(Diffie-Hellman)算法的公钥和私钥，并根据指明的编码方式返回公钥。这个公钥可以转交给第三方。编码方式可以是 <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>或 <code>&apos;base64&apos;</code>.  如果没有指明编码方式，则返回一个buffer对象。

</p>
</div>

<div class="translate-section" data-hash="43b437e163a4d26bd0c5790f06e5b44b">

<h3>diffieHellman.computeSecret(other_public_key, [input_encoding], [output_encoding])<span><a href="#crypto_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding_938" id="crypto_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="808c62a97f4baec709cbc6cebcb50b5e">

<p>以<code>other_public_key</code>作为第三方公钥来计算共享秘密，并返回这个共享秘密。参数中的密钥会以<code>input_encoding</code>编码方式来解读，而共享密钥则会用<code>output_encoding</code>进行编码。编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>或 <code>&apos;base64&apos;</code>。如果没有提供输入的编码方式，则默认为一个buffer对象。

</p>
</div>

<div class="translate-section" data-hash="26c312a3691f4f27c1b86c0d8406a6ef">

<p>如果没有指明输出的编码方式，则返回一个buffer对象。

</p>
</div>

<div class="translate-section" data-hash="29b66c2658c7c272853b55c2f3dfeef5">

<h3>diffieHellman.getPrime([encoding])<span><a href="#crypto_diffiehellman_getprime_encoding_938" id="crypto_diffiehellman_getprime_encoding_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="e63c656ea6a5dc4473180cdd9ee5b6f8">

<p>根据指明的编码格式返回迪菲－赫尔曼(Diffie-Hellman)质数，其中编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。

</p>
</div>

<div class="translate-section" data-hash="ec6e5cc1602b36480d28042780da3be3">

<h3>diffieHellman.getGenerator([encoding])<span><a href="#crypto_diffiehellman_getgenerator_encoding_938" id="crypto_diffiehellman_getgenerator_encoding_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="e63c656ea6a5dc4473180cdd9ee5b6f8">

<p>根据指明的编码格式返回迪菲－赫尔曼(Diffie-Hellman)质数，其中编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。

</p>
</div>

<div class="translate-section" data-hash="9d1a5a8e575c5230e3e422357ebb585a">

<h3>diffieHellman.getPublicKey([encoding])<span><a href="#crypto_diffiehellman_getpublickey_encoding_938" id="crypto_diffiehellman_getpublickey_encoding_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="cc4a17b50af704719a420aceb0725251">

<p>根据指明的编码格式返回迪菲－赫尔曼(Diffie-Hellman)公钥，其中编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。 如果没有指明编码方式，则返回一个buffer对象。

</p>
</div>

<div class="translate-section" data-hash="bda81af80547e5f4e4d0969133dd6613">

<h3>diffieHellman.getPrivateKey([encoding])<span><a href="#crypto_diffiehellman_getprivatekey_encoding_938" id="crypto_diffiehellman_getprivatekey_encoding_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="66c3d5c00390e9e611dab5cd2d7e2453">

<p>根据指明的编码格式返回迪菲－赫尔曼(Diffie-Hellman)私钥，其中编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。

</p>
</div>

<div class="translate-section" data-hash="6a6a3d1c1613b937b528313607a65bb2">

<h3>diffieHellman.setPublicKey(public_key, [encoding])<span><a href="#crypto_diffiehellman_setpublickey_public_key_encoding_938" id="crypto_diffiehellman_setpublickey_public_key_encoding_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="9d620b942e8ae8423d2b26fe382cacf8">

<p>设置迪菲－赫尔曼(Diffie-Hellman)公钥，编码方式可以是可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。

</p>
</div>

<div class="translate-section" data-hash="d53c7025bd7afc9e9fe371e81d552143">

<h3>diffieHellman.setPrivateKey(private_key, [encoding])<span><a href="#crypto_diffiehellman_setprivatekey_private_key_encoding_938" id="crypto_diffiehellman_setprivatekey_private_key_encoding_938">#</a></span></h3>
</div>

<div class="translate-section" data-hash="c56e2ccb2d51d6a3109a4e0184e63929">

<p>设置迪菲－赫尔曼(Diffie-Hellman)私钥，编码方式可以是可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。

</p>
</div>

<div class="translate-section" data-hash="f537b892341e68a510604b702380e508">

<h2>crypto.getDiffieHellman(group_name)<span><a href="#crypto_crypto_getdiffiehellman_group_name_938" id="crypto_crypto_getdiffiehellman_group_name_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="9590bcf721ca1b5cfc0dc6047033e313">

<p>创建一个预定义的迪菲－赫尔曼密钥交换(Diffie-Hellman key exchanges)对象。支持以下的D-H组：<code>&apos;modp1&apos;</code>, <code>&apos;modp2&apos;</code>, <code>&apos;modp5&apos;</code> (在<a href="http://www.rfc-editor.org/rfc/rfc2412.txt">RFC
2412</a>中定义) 和 <code>&apos;modp14&apos;</code>, <code>&apos;modp15&apos;</code>, <code>&apos;modp16&apos;</code>, <code>&apos;modp17&apos;</code>,
<code>&apos;modp18&apos;</code> (在 <a href="http://www.rfc-editor.org/rfc/rfc3526.txt">RFC 3526</a>中定义)。返回的对象模仿了上述 <a href="#crypto_crypto_creatediffiehellman_prime_encoding">crypto.createDiffieHellman()</a>方法所创建的对象的接口，但不会晕允许密钥交换
(例如像
<a href="#crypto_diffiehellman_setpublickey_public_key_encoding">diffieHellman.setPublicKey()</a>那样)。执行这套流程的好处是双方不需要事先生成或交换组余数，节省了处理和通信时间。

</p>
</div>

<div class="translate-section" data-hash="199c3c0e031133252349c8cfb946fba4">

<p>例子 (获取一个共享秘密):

</p>
</div>

<div class="translate-section" data-hash="c17cb487f6cdbfa8db5741992aa015ff">

<pre><code>/* alice_secret和 bob_secret应该是一样的 */
console.log(alice_secret == bob_secret);</code></pre>
</div>

<div class="translate-section" data-hash="929d6a5650663a271f29f52c0f4be4c2">

<h2>crypto.pbkdf2(password, salt, iterations, keylen, callback)<span><a href="#crypto_crypto_pbkdf2_password_salt_iterations_keylen_callback_938" id="crypto_crypto_pbkdf2_password_salt_iterations_keylen_callback_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="b70acb24ac699bb29375e0837caafd2a">

<p>异步PBKDF2提供了一个伪随机函数 HMAC-SHA1，根据给定密码的长度，salt和iterations来得出一个密钥。回调函数得到两个参数 <code>(err, derivedKey)</code>。

</p>
</div>

<div class="translate-section" data-hash="511407189f414060a6edb59c9a266982">

<h2>crypto.pbkdf2Sync(password, salt, iterations, keylen)<span><a href="#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_938" id="crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="09310772478a05323173cbd96c178e92">

<p>同步 PBKDF2 函数。返回derivedKey或抛出一个错误。

</p>
</div>

<div class="translate-section" data-hash="7821ce45817722eb8395657ba1da2d62">

<h2>crypto.randomBytes(size, [callback])<span><a href="#crypto_crypto_randombytes_size_callback_938" id="crypto_crypto_randombytes_size_callback_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="bd0c343712d6e952602c21ddbe1c4339">

<p>生成密码学强度的伪随机数据。用法：

</p>
</div>

<div class="translate-section" data-hash="b65d8c22286cfe0b7df7729bb2e1371a">

<pre><code>// 同步
try {
  var buf = crypto.randomBytes(256);
  console.log(&apos;有 %d 字节的随机数据： %s&apos;, buf.length, buf);
} catch (ex) {
  // handle error
}</code></pre>
</div>

<div class="translate-section" data-hash="2f06d861fce688c13e531f06bfc0241d">

<h2>crypto.pseudoRandomBytes(size, [callback])<span><a href="#crypto_crypto_pseudorandombytes_size_callback_938" id="crypto_crypto_pseudorandombytes_size_callback_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="5d41e9b06720ce77a689946eec27c5fc">

<p>生成<em>非</em>密码学强度的伪随机数据。如果数据足够长的话会返回一个唯一的数据，但这个返回值不一定是不可预料的。基于这个原因，当不可预料性很重要时，这个函数的返回值永远都不应该被使用，例如在生成加密的密钥时。

</p>
</div>

<div class="translate-section" data-hash="d4d401daac83c36973cf4c328dd0b4c8">

<p>用法与 <code>crypto.randomBytes</code>一模一样。

</p>
</div>

<div class="translate-section" data-hash="a3cbebabd9a8e6772a735744406b8252">

<h2>crypto.DEFAULT_ENCODING<span><a href="#crypto_crypto_default_encoding_938" id="crypto_crypto_default_encoding_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="f99da6b7d4bb5a4555d94d4529df5378">

<p>对于可以接受字符串或buffer对象的函数的默认编码方式。默认值是<code>&apos;buffer&apos;</code>，所以默认使用Buffer对象。这是为了让crypto模块与默认<code>&apos;binary&apos;</code>为编码方式的遗留程序更容易兼容。

</p>
</div>

<div class="translate-section" data-hash="a8c0a979fbf2c533da3021eee88382a9">

<p>要注意，新的程序会期待buffer对象，所以使用这个时请只作为暂时的手段。

</p>
</div>

<div class="translate-section" data-hash="5f3086092b69c58cdba8fc31f5a1d87e">

<h2>Recent API Changes<span><a href="#crypto_recent_api_changes_938" id="crypto_recent_api_changes_938">#</a></span></h2>
</div>

<div class="translate-section" data-hash="d1ffaccd5e7ea9c3c8fe102eb39818ba">

<p>早在统一的流API概念出现，以及引入Buffer对象来处理二进制数据之前，Crypto模块就被添加到Node。

</p>
</div>

<div class="translate-section" data-hash="49d176315e67768b1d5d18bbb7d579c3">

<p>因为这样，与流有关的类中并没有其它Node类的典型函数，而且很多函数接受和返回默认的二进制编码的字符串，而不是Buffer对象。在最近的修改中，这些函数都被改成默认使用Buffer对象。

</p>
</div>

<div class="translate-section" data-hash="96d7981639c73744c05e0d01b1a02980">

<p>这对于某些(但不是全部)使用场景来讲是重大的改变。

</p>
</div>

<div class="translate-section" data-hash="425362612fcc08afd4e065207b647b7d">

<p>例如，如果你现在使用Sign类的默认参数，然后在没有检查数据的情况下，将结果传递给Verify类，那么程序会照常工作。在以前，你会拿到一个二进制字符串，然后它传递给Verify对象；而现在，你会得到一个Buffer对象，然后把它传递给Verify对象。

</p>
</div>

<div class="translate-section" data-hash="2e7369569fbad0253cb1a1926b783389">

<p>但是，如果你以前是使用那些在Buffer对象上不能正常工作的字符串数据，或者以默认编码方式将二进制数据传递给加密函数的话，那你就要开始提供编码方式参数来指明你想使用的编码方式了。如果想准换回旧的风格默认使用二进制字符串，那么你需要把<code>crypto.DEFAULT_ENCODING</code>字段设为&apos;binary&apos;。但请注意，因为新的程序很可能会期望buffer对象，所以仅将此当做临时手段。

</p>
</div>

<div class="translate-section" data-hash="12fb0684f66a6fd6808e8446c1d63538">

</div>
          </div>
        </div>
    </div>
    <div id="footer">
        <a href="http://joyent.com" class="joyent-logo">Joyent</a>
        <ul class="clearfix">
            <li><a href="http://nodejs.org/">Node.js</a></li>
            <li><a href="http://nodejs.org/download/">Download</a></li>
            <li><a href="http://nodejs.org/about/">About</a></li>
            <li><a href="http://npmjs.org/">npm Registry</a></li>
            <li><a href="http://nodejs.org/api/">Docs</a></li>
            <li><a href="http://blog.nodejs.org">Blog</a></li>
            <li><a href="http://nodejs.org/community/">Community</a></li>
            <li><a href="http://nodejs.org/logos/">Logos</a></li>
            <li><a href="http://jobs.nodejs.org/">Jobs</a></li>
            <li><a href="http://twitter.com/nodejs" class="twitter">@nodejs</a></li>
        </ul>

        <p>Copyright <a href="http://joyent.com/">Joyent, Inc</a>, Node.js is a <a href="/trademark-policy.pdf">trademark</a> of Joyent, Inc. View <a href="https://raw.github.com/joyent/node/v0.10.18/LICENSE">license</a>.</p>
    </div>

  <script src="/public/api_assets/sh_main.js"></script>
  <script src="/public/api_assets/sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>
</body>
</html>

<!-- google analytics -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-26599868-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

<script src="/public/js/jquery.js"></script>
<script>
$('.translate-section').each(function () {
  var html = '<div class="op">' +
               '<button class="show-origin">显示原文</button>' +
               '<button class="btn btn-xs btn-info">其他翻译</button>' +
               '<button class="btn btn-xs btn-info">纠错</button>' +
              '</div>';
  $(this).prepend(html);
});

// 显示原文
$('.translate-section').delegate('.show-origin', 'click', function () {
  var $section = $(this).closest('.translate-section');
  var hash = $section.data('hash');
  $.get('/translate/get/origin', {hash: hash}, function (d) {
    if (d.error) return alert(d.error);

    $section.find('.origin').remove();
    $section.append('<div class="origin">' + d.html + '</div>');
    highlight(undefined, undefined, 'code');
  });
});
</script>